var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
define("back", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function arr_back(arr) {
        return arr[arr.length - 1];
    }
    exports.default = arr_back;
});
define("nodes/type", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NodeType;
    (function (NodeType) {
        NodeType[NodeType["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
        NodeType[NodeType["TEXT_NODE"] = 3] = "TEXT_NODE";
        NodeType[NodeType["COMMENT_NODE"] = 8] = "COMMENT_NODE";
    })(NodeType || (NodeType = {}));
    exports.default = NodeType;
});
define("nodes/node", ["require", "exports", "he"], function (require, exports, he_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Node Class as base class for TextNode and HTMLElement.
     */
    var Node = /** @class */ (function () {
        function Node(parentNode, range) {
            if (parentNode === void 0) { parentNode = null; }
            this.parentNode = parentNode;
            this.childNodes = [];
            Object.defineProperty(this, 'range', {
                enumerable: false,
                writable: true,
                configurable: true,
                value: range !== null && range !== void 0 ? range : [-1, -1]
            });
        }
        /**
         * Remove current node
         */
        Node.prototype.remove = function () {
            var _this = this;
            if (this.parentNode) {
                var children = this.parentNode.childNodes;
                this.parentNode.childNodes = children.filter(function (child) {
                    return _this !== child;
                });
                this.parentNode = null;
            }
            return this;
        };
        Object.defineProperty(Node.prototype, "innerText", {
            get: function () {
                return this.rawText;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "textContent", {
            get: function () {
                return (0, he_1.decode)(this.rawText);
            },
            set: function (val) {
                this.rawText = (0, he_1.encode)(val);
            },
            enumerable: false,
            configurable: true
        });
        return Node;
    }());
    exports.default = Node;
});
define("matcher", ["require", "exports", "nodes/type"], function (require, exports, type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    type_1 = __importDefault(type_1);
    function isTag(node) {
        return node && node.nodeType === type_1.default.ELEMENT_NODE;
    }
    function getAttributeValue(elem, name) {
        return isTag(elem) ? elem.getAttribute(name) : undefined;
    }
    function getName(elem) {
        return ((elem && elem.rawTagName) || '').toLowerCase();
    }
    function getChildren(node) {
        return node && node.childNodes;
    }
    function getParent(node) {
        return node ? node.parentNode : null;
    }
    function getText(node) {
        return node.text;
    }
    function removeSubsets(nodes) {
        var idx = nodes.length;
        var node;
        var ancestor;
        var replace;
        // Check if each node (or one of its ancestors) is already contained in the
        // array.
        while (--idx > -1) {
            node = ancestor = nodes[idx];
            // Temporarily remove the node under consideration
            nodes[idx] = null;
            replace = true;
            while (ancestor) {
                if (nodes.indexOf(ancestor) > -1) {
                    replace = false;
                    nodes.splice(idx, 1);
                    break;
                }
                ancestor = getParent(ancestor);
            }
            // If the node has been found to be unique, re-insert it.
            if (replace) {
                nodes[idx] = node;
            }
        }
        return nodes;
    }
    function existsOne(test, elems) {
        return elems.some(function (elem) {
            return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
        });
    }
    function getSiblings(node) {
        var parent = getParent(node);
        return parent && getChildren(parent);
    }
    function hasAttrib(elem, name) {
        return getAttributeValue(elem, name) !== undefined;
    }
    function findOne(test, elems) {
        var elem = null;
        for (var i = 0, l = elems.length; i < l && !elem; i++) {
            var el = elems[i];
            if (test(el)) {
                elem = el;
            }
            else {
                var childs = getChildren(el);
                if (childs && childs.length > 0) {
                    elem = findOne(test, childs);
                }
            }
        }
        return elem;
    }
    function findAll(test, nodes) {
        var result = [];
        for (var i = 0, j = nodes.length; i < j; i++) {
            if (!isTag(nodes[i]))
                continue;
            if (test(nodes[i]))
                result.push(nodes[i]);
            var childs = getChildren(nodes[i]);
            if (childs)
                result = result.concat(findAll(test, childs));
        }
        return result;
    }
    exports.default = {
        isTag: isTag,
        getAttributeValue: getAttributeValue,
        getName: getName,
        getChildren: getChildren,
        getParent: getParent,
        getText: getText,
        removeSubsets: removeSubsets,
        existsOne: existsOne,
        getSiblings: getSiblings,
        hasAttrib: hasAttrib,
        findOne: findOne,
        findAll: findAll
    };
});
define("void-tag", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VoidTag = /** @class */ (function () {
        function VoidTag(addClosingSlash, tags) {
            if (addClosingSlash === void 0) { addClosingSlash = false; }
            this.addClosingSlash = addClosingSlash;
            if (Array.isArray(tags)) {
                this.voidTags = tags.reduce(function (set, tag) {
                    return set.add(tag.toLowerCase());
                }, new Set());
            }
            else {
                this.voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'].reduce(function (set, tag) {
                    return set.add(tag);
                }, new Set());
            }
        }
        VoidTag.prototype.formatNode = function (tag, attrs, innerHTML) {
            var addClosingSlash = this.addClosingSlash;
            var closingSpace = (addClosingSlash && attrs && !attrs.endsWith(' ')) ? ' ' : '';
            var closingSlash = addClosingSlash ? "".concat(closingSpace, "/") : '';
            return this.isVoidElement(tag.toLowerCase()) ? "<".concat(tag).concat(attrs).concat(closingSlash, ">") : "<".concat(tag).concat(attrs, ">").concat(innerHTML, "</").concat(tag, ">");
        };
        VoidTag.prototype.isVoidElement = function (tag) {
            return this.voidTags.has(tag);
        };
        return VoidTag;
    }());
    exports.default = VoidTag;
});
define("nodes/text", ["require", "exports", "he", "nodes/node", "nodes/type"], function (require, exports, he_2, node_1, type_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    node_1 = __importDefault(node_1);
    type_2 = __importDefault(type_2);
    /**
     * TextNode to contain a text element in DOM tree.
     * @param {string} value [description]
     */
    var TextNode = /** @class */ (function (_super) {
        __extends(TextNode, _super);
        function TextNode(rawText, parentNode, range) {
            var _this = _super.call(this, parentNode, range) || this;
            /**
             * Node Type declaration.
             * @type {Number}
             */
            _this.nodeType = type_2.default.TEXT_NODE;
            _this._rawText = rawText;
            return _this;
        }
        TextNode.prototype.clone = function () {
            return new TextNode(this._rawText, null);
        };
        Object.defineProperty(TextNode.prototype, "rawText", {
            get: function () {
                return this._rawText;
            },
            /**
             * Set rawText and invalidate trimmed caches
             */
            set: function (text) {
                this._rawText = text;
                this._trimmedRawText = void 0;
                this._trimmedText = void 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextNode.prototype, "trimmedRawText", {
            /**
             * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space
             */
            get: function () {
                if (this._trimmedRawText !== undefined)
                    return this._trimmedRawText;
                this._trimmedRawText = trimText(this.rawText);
                return this._trimmedRawText;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextNode.prototype, "trimmedText", {
            /**
             * Returns text with all whitespace trimmed except single leading/trailing non-breaking space
             */
            get: function () {
                if (this._trimmedText !== undefined)
                    return this._trimmedText;
                this._trimmedText = trimText(this.text);
                return this._trimmedText;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextNode.prototype, "text", {
            /**
             * Get unescaped text value of current node and its children.
             * @return {string} text content
             */
            get: function () {
                return (0, he_2.decode)(this.rawText);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextNode.prototype, "isWhitespace", {
            /**
             * Detect if the node contains only white space.
             * @return {boolean}
             */
            get: function () {
                return /^(\s|&nbsp;)*$/.test(this.rawText);
            },
            enumerable: false,
            configurable: true
        });
        TextNode.prototype.toString = function () {
            return this.rawText;
        };
        return TextNode;
    }(node_1.default));
    exports.default = TextNode;
    /**
     * Trim whitespace except single leading/trailing non-breaking space
     */
    function trimText(text) {
        var i = 0;
        var startPos;
        var endPos;
        while (i >= 0 && i < text.length) {
            if (/\S/.test(text[i])) {
                if (startPos === undefined) {
                    startPos = i;
                    i = text.length;
                }
                else {
                    endPos = i;
                    i = void 0;
                }
            }
            if (startPos === undefined)
                i++;
            else
                i--;
        }
        if (startPos === undefined)
            startPos = 0;
        if (endPos === undefined)
            endPos = text.length - 1;
        var hasLeadingSpace = startPos > 0 && /[^\S\r\n]/.test(text[startPos - 1]);
        var hasTrailingSpace = endPos < (text.length - 1) && /[^\S\r\n]/.test(text[endPos + 1]);
        return (hasLeadingSpace ? ' ' : '') + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? ' ' : '');
    }
});
define("nodes/html", ["require", "exports", "css-select", "he", "back", "matcher", "void-tag", "nodes/comment", "nodes/node", "nodes/text", "nodes/type"], function (require, exports, css_select_1, he_3, back_1, matcher_1, void_tag_1, comment_1, node_2, text_1, type_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.base_parse = void 0;
    he_3 = __importDefault(he_3);
    back_1 = __importDefault(back_1);
    matcher_1 = __importDefault(matcher_1);
    void_tag_1 = __importDefault(void_tag_1);
    comment_1 = __importDefault(comment_1);
    node_2 = __importDefault(node_2);
    text_1 = __importDefault(text_1);
    type_3 = __importDefault(type_3);
    function decode(val) {
        // clone string
        return JSON.parse(JSON.stringify(he_3.default.decode(val)));
    }
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
    var Htags = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup'];
    var Dtags = ['details', 'dialog', 'dd', 'div', 'dt'];
    var Ftags = ['fieldset', 'figcaption', 'figure', 'footer', 'form'];
    var tableTags = ['table', 'td', 'tr'];
    var htmlTags = ['address', 'article', 'aside', 'blockquote', 'br', 'hr', 'li', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'ul'];
    var kBlockElements = new Set();
    function addToKBlockElement() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var addToSet = function (array) {
            for (var index = 0; index < array.length; index++) {
                var element = array[index];
                kBlockElements.add(element);
                kBlockElements.add(element.toUpperCase());
            }
        };
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            addToSet(arg);
        }
    }
    addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
    var DOMTokenList = /** @class */ (function () {
        function DOMTokenList(valuesInit, afterUpdate) {
            if (valuesInit === void 0) { valuesInit = []; }
            if (afterUpdate === void 0) { afterUpdate = function () { return null; }; }
            this._set = new Set(valuesInit);
            this._afterUpdate = afterUpdate;
        }
        DOMTokenList.prototype._validate = function (c) {
            if (/\s/.test(c)) {
                throw new Error("DOMException in DOMTokenList.add: The token '".concat(c, "' contains HTML space characters, which are not valid in tokens."));
            }
        };
        DOMTokenList.prototype.add = function (c) {
            this._validate(c);
            this._set.add(c);
            this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call
        };
        DOMTokenList.prototype.replace = function (c1, c2) {
            this._validate(c2);
            this._set.delete(c1);
            this._set.add(c2);
            this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call
        };
        DOMTokenList.prototype.remove = function (c) {
            this._set.delete(c) && this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call
        };
        DOMTokenList.prototype.toggle = function (c) {
            this._validate(c);
            if (this._set.has(c))
                this._set.delete(c);
            else
                this._set.add(c);
            this._afterUpdate(this); // eslint-disable-line @typescript-eslint/no-unsafe-call
        };
        DOMTokenList.prototype.contains = function (c) {
            return this._set.has(c);
        };
        Object.defineProperty(DOMTokenList.prototype, "length", {
            get: function () {
                return this._set.size;
            },
            enumerable: false,
            configurable: true
        });
        DOMTokenList.prototype.values = function () {
            return this._set.values();
        };
        Object.defineProperty(DOMTokenList.prototype, "value", {
            get: function () {
                return Array.from(this._set.values());
            },
            enumerable: false,
            configurable: true
        });
        DOMTokenList.prototype.toString = function () {
            return Array.from(this._set.values()).join(' ');
        };
        return DOMTokenList;
    }());
    /**
     * HTMLElement, which contains a set of children.
     *
     * Note: this is a minimalist implementation, no complete tree
     *   structure provided (no parentNode, nextSibling,
     *   previousSibling etc).
     * @class HTMLElement
     * @extends {Node}
     */
    var HTMLElement = /** @class */ (function (_super) {
        __extends(HTMLElement, _super);
        /**
         * Creates an instance of HTMLElement.
         * @param keyAttrs	id and class attribute
         * @param [rawAttrs]	attributes in string
         *
         * @memberof HTMLElement
         */
        function HTMLElement(tagName, keyAttrs, rawAttrs, parentNode, range, voidTag) {
            if (rawAttrs === void 0) { rawAttrs = ''; }
            if (voidTag === void 0) { voidTag = new void_tag_1.default(); }
            var _this = _super.call(this, parentNode, range) || this;
            _this.rawAttrs = rawAttrs;
            _this.voidTag = voidTag;
            /**
             * Node Type declaration.
             */
            _this.nodeType = type_3.default.ELEMENT_NODE;
            _this.rawTagName = tagName;
            _this.rawAttrs = rawAttrs || '';
            _this.id = keyAttrs.id || '';
            _this.childNodes = [];
            _this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\s+/) : [], function (classList) { return _this.setAttribute('class', classList.toString()); } // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            );
            if (keyAttrs.id) {
                if (!rawAttrs) {
                    _this.rawAttrs = "id=\"".concat(keyAttrs.id, "\"");
                }
            }
            if (keyAttrs.class) {
                if (!rawAttrs) {
                    var cls = "class=\"".concat(_this.classList.toString(), "\"");
                    if (_this.rawAttrs) {
                        _this.rawAttrs += " ".concat(cls);
                    }
                    else {
                        _this.rawAttrs = cls;
                    }
                }
            }
            return _this;
        }
        /**
         * Quote attribute values
         * @param attr attribute value
         * @returns {string} quoted value
         */
        HTMLElement.prototype.quoteAttribute = function (attr) {
            if (attr == null) {
                return 'null';
            }
            return JSON.stringify(attr.replace(/"/g, '&quot;'));
        };
        /**
         * Remove Child element from childNodes array
         * @param {HTMLElement} node     node to remove
         */
        HTMLElement.prototype.removeChild = function (node) {
            this.childNodes = this.childNodes.filter(function (child) {
                return child !== node;
            });
            return this;
        };
        /**
         * Exchanges given child with new child
         * @param {HTMLElement} oldNode     node to exchange
         * @param {HTMLElement} newNode     new node
         */
        HTMLElement.prototype.exchangeChild = function (oldNode, newNode) {
            var children = this.childNodes;
            this.childNodes = children.map(function (child) {
                if (child === oldNode) {
                    return newNode;
                }
                return child;
            });
            return this;
        };
        Object.defineProperty(HTMLElement.prototype, "tagName", {
            get: function () {
                return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
            },
            set: function (newname) {
                this.rawTagName = newname.toLowerCase();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "localName", {
            get: function () {
                return this.rawTagName.toLowerCase();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "isVoidElement", {
            get: function () {
                return this.voidTag.isVoidElement(this.localName);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "rawText", {
            /**
             * Get escpaed (as-it) text value of current node and its children.
             * @return {string} text content
             */
            get: function () {
                return this.childNodes.reduce(function (pre, cur) {
                    return (pre += cur.rawText);
                }, '');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "textContent", {
            get: function () {
                return decode(this.rawText);
            },
            set: function (val) {
                var content = [new text_1.default(val, this)];
                this.childNodes = content;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "text", {
            /**
             * Get unescaped text value of current node and its children.
             * @return {string} text content
             */
            get: function () {
                return decode(this.rawText);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HTMLElement.prototype, "structuredText", {
            /**
             * Get structured Text (with '\n' etc.)
             * @return {string} structured text
             */
            get: function () {
                var currentBlock = [];
                var blocks = [currentBlock];
                function dfs(node) {
                    if (node.nodeType === type_3.default.ELEMENT_NODE) {
                        if (kBlockElements.has(node.rawTagName)) {
                            if (currentBlock.length > 0) {
                                blocks.push((currentBlock = []));
                            }
                            node.childNodes.forEach(dfs);
                            if (currentBlock.length > 0) {
                                blocks.push((currentBlock = []));
                            }
                        }
                        else {
                            node.childNodes.forEach(dfs);
                        }
                    }
                    else if (node.nodeType === type_3.default.TEXT_NODE) {
                        if (node.isWhitespace) {
                            // Whitespace node, postponed output
                            currentBlock.prependWhitespace = true;
                        }
                        else {
                            var text = node.trimmedText;
                            if (currentBlock.prependWh